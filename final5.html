v<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Mon Application Web</title>
    <style>
        /* Styles CSS pour le bouton */
        .button {
            background-color: #4CAF50; /* couleur de fond verte */
            border: none;
            color: white; /* couleur du texte blanc */
            padding: 15px 32px; /* taille du bouton */
            text-align: center;
            text-decoration: none;
            display: inline-block;
            font-size: 16px;
            margin: 4px 2px;
            cursor: pointer;
            border-radius: 10px; /* coins arrondis */
            box-shadow: 0 4px 8px 0 rgba(0,0,0,0.2); /* ombre */
            transition: box-shadow 0.3s ease; /* transition douce de l'ombre */
        }
        /* Au survol, agrandir légèrement le bouton */
        .button:hover {
            box-shadow: 0 8px 16px 0 rgba(0,0,0,0.2);
        }
        /* Styles CSS pour le canvas */
        canvas {
            border: 1px solid black;
        }
    </style>
</head>
<body>
    <h1>Bienvenue sur Mon Application Web !</h1>
    <p>Cette application est en cours de développement. voici ce qu'il faut rajouter :</p>
    <ul>
        <li>performance du tri :temps d'execution (avec ou sans l'attente jsp), nombre de comparaison, nombre de déplacement de vlaeur</li>
        <li>boutton d'arret complet + si on stop puis recommence ça reste statique</li>
        <li>pouvoir selecioner entre quoi et quoi les valeurs sont comprisent </li>
        <li> rajouter de algorithmes</li>
        <li>rendre ça beau </li>
    </ul>

    <select id="mySelect">
        <option value="1">Tri à bulles</option>
        <option value="2">Tri par sélection</option>
        <option value="3">Tri à peigne</option>
        <option value="4">Tri par tas</option>
        <option value="5">Tri rapide</option>
        <option value="6">Tri fusion</option>
        <!-- Ajoute d'autres options pour d'autres algorithmes de tri -->
    </select>
    <canvas id="visualization" width="800" height="400"></canvas>

    <p id="executionTime"></p>

    <button id="idbutton" class="button" onclick="SortVisualization()">Go</button>

    <label for="arraySize">Taille du tableau : </label>
    <input type="number" id="arraySize" name="arraySize" min="1" max="10000" value="100">
    <label for="awaittime">délais d'attente : </label>
    <input type="number" id="awaittime" name="awaittime" min="1" max="1000" value="30">ms


    <div id="errorMessage" style="display: none; color: red;"></div>

    <button class="button" onclick="stopFunction()">stop</button>
    <button class="button" onclick="resumeFunction()">resume</button>
    <button class="button" onclick="onestepFunction()">one step</button>
    <button class="button" onclick="resetFunction()">reset</button>
    <script>
        //constantes :
        let selectValue;
        let ValueInput;
        let stopExecution = false;
        let onestep = false;
        let resume = false;
        let running = false;
        let reset = false;
        let startTime; //temps de debut
        let endTime;   //temps fin
        let executionTimeInSeconds = 0;
        let comparaisonCount = 0; // cpt
        let echangeCount = 0;   // cpt
        let indexswap1;
        let indexswap2;
        let awaittime=30; 

        window.onload = init();

        function init() {
            getSelectValue();
            getValueInput();
            getAwaittime();
            var array = generateRandomArray(ValueInput);
            drawArray(array);
        }

        //récupère la valeur dans le choix du tri
        function getSelectValue()
        {
        const selectElement = document.querySelector('#mySelect');
        selectValue = selectElement.value;
        }

        function getValueInput() {
            var inputElement = document.getElementById("arraySize");
            // Récupérer la valeur de l'attribut value
            ValueInput = inputElement.value;
        }

        function getAwaittime() {
            var inputElement = document.getElementById("awaittime");
            awaittime = inputElement.value;
        }        

        function stopFunction() {
            stopExecution = true;
        }

        function onestepFunction() {
            onestep = true;
        }

        function resumeFunction() {
            resume=true;
        }

        function resetFunction() {
            reset = true;
        }

        function startFunction(){
            stopExecution = false;
            onestep = false;
            resume = false;
            indexfuctionswap(-1,-1);
        }

        function endFunction() {
            running = false;
        }

        function indexfuctionswap(a, b){
            indexswap1=a;
            indexswap2=b;
        }

        //affiche le message d'erreur
        function AfficheErreur(message) {
            var errorMessageElement = document.getElementById("errorMessage");
            errorMessageElement.innerText = message;
            errorMessageElement.style.display = "block";
        }

        function drawArray(array) {
            var canvas = document.getElementById("visualization");
            var ctx = canvas.getContext("2d");
            var n = array.length;
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            var barWidth = canvas.width / n;
            var barHeightRatio = canvas.height / Math.max(...array);
            for (var i = 0; i < n; i++) {
                var barHeight = array[i] * barHeightRatio;
                if(i === indexswap1 || i === indexswap2){
                    ctx.fillStyle = "red"; // couleur rouge pour les indices définis
                } else {
                    ctx.fillStyle = "blue"; // couleur bleue pour les autres indices
                }
                ctx.fillRect(i * barWidth, canvas.height - barHeight, barWidth, barHeight);
            }
        }

        function SortVisualization() {
            if(running){return;}
            getSelectValue();
            getValueInput();
            getAwaittime();
            if(isNaN(ValueInput) || ValueInput <3 || ValueInput > 10000) {
                AfficheErreur("la valeur doit être compris entre 3 et 10000");
                return;
            }
            stopExecution = false;
            onestep = false;
            resume = false;
            running = false;
            reset = false;
            var canvas = document.getElementById("visualization");
            var ctx = canvas.getContext("2d");
            var array = generateRandomArray(ValueInput); // Génère un tableau de ValueInput éléments aléatoires
            var n = array.length;

            // Fonction pour effectuer le tri à bulles et dessiner chaque étape sur le canvas
            async function bubbleSort() {
                startTime = performance.now();
                running = true;
                startFunction();
                comparaisonCount = 0;
                echangeCount = 0;
                indexfuctionswap(-1,-1);
                for (var i = 0; i < n - 1; i++) {
                    if (stopExecution) {
                        break;
                    }
                    for (var j = 0; j < n - i - 1; j++) {
                        comparaisonCount++;
                        if (array[j] > array[j + 1]) {
                            echangeCount++;
                            indexfuctionswap(j,j+1);
                            // Échange les éléments
                            var temp = array[j];
                            array[j] = array[j + 1];
                            array[j + 1] = temp;
                            // Dessine le tableau après chaque échange
                            drawArray(array);
                            await new Promise(resolve => setTimeout(resolve, awaittime));
                            if(reset) {
                                resetFunction();
                                reset=false;
                                running=false;
                                return;
                            }
                            if(stopExecution) {
                                while(!(onestep||resume||reset)){
                                    await new Promise(resolve => setTimeout(resolve, 50));
                                }
                                if(onestep) {
                                    onestep=false;
                                    stopExecution=true;
                                }
                                if(resume) {
                                    resume=false;
                                    stopExecution=false;
                                    onestep=false;
                                }
                                if (reset) {
                                    resetFunction();
                                    reset = false;
                                    running = false;
                                    return;
                                }
                            }
                        }
                    }
                }
                endTime = performance.now();
                const executionTime = endTime - startTime;
                console.log("Temps d'exécution pour le tri à bulles (s) : ", executionTime/1000);
                const executionTimeElement = document.getElementById('executionTime');
                executionTimeElement.innerText = `Temps d'exécution : ${(executionTime/1000).toFixed(2)} s`;
                executionTimeElement.innerText += `\nNombre de comparaisons : ${comparaisonCount}`;
                executionTimeElement.innerText += `\nNombre d'échanges : ${echangeCount}`;
                running = false;
            }

            // Fonction pour effectuer le tri par sélection et dessiner chaque étape sur le canvas
            async function selectionSort() {
                startTime = performance.now();
                startFunction();
                running=true;
                comparaisonCount = 0;
                echangeCount = 0;
                indexfuctionswap(-1,-1);
                for (var i = 0; i < n - 1; i++) {
                    if (stopExecution) {
                        break;
                    }
                    var minIndex = i;
                    for (var j = i + 1; j < n; j++) {
                        comparaisonCount++;
                        if (array[j] < array[minIndex]) {
                            minIndex = j;
                        }
                    }
                    if (minIndex != i) {
                        echangeCount++;
                        indexfuctionswap(i,minIndex);
                        // Échange les éléments
                        var temp = array[i];
                        array[i] = array[minIndex];
                        array[minIndex] = temp;
                        // Dessine le tableau après chaque échange
                        drawArray(array);
                        await new Promise(resolve => setTimeout(resolve, awaittime));
                        if(reset) {
                            resetFunction();
                            reset=false;
                            running=false;
                            return;
                        }
                        if(stopExecution) {
                            while(!(onestep||resume)){
                                await new Promise(resolve => setTimeout(resolve, 50));
                            }
                            if(onestep) {
                                onestep=false;
                                stopExecution=true;
                            }
                            if(resume) {
                                resume=false;
                                stopExecution=false;
                                onestep=false;
                            }
                            if (reset) {
                                resetFunction();
                                reset = false;
                                running = false;
                                return;
                            }
                        }
                    }
                }
                endTime = performance.now();
                const executionTime = endTime - startTime;
                console.log("Temps d'exécution pour le tri par selection (s) : ", executionTime/1000);
                const executionTimeElement = document.getElementById('executionTime');
                executionTimeElement.innerText = `Temps d'exécution : ${(executionTime/1000).toFixed(2)} s`;
                executionTimeElement.innerText += `\nNombre de comparaisons : ${comparaisonCount}`;
                executionTimeElement.innerText += `\nNombre d'échanges : ${echangeCount}`;
                running=false;
            }

            // Fonction pour effectuer le tri à peigne et dessiner chaque étape sur le canvas
            async function combSort() {
                startTime = performance.now();
                startFunction();
                running=true;
                let gap = n;
                let shrink = 1.3;
                let sorted = false;
                comparaisonCount = 0;
                echangeCount = 0;
                indexfuctionswap(-1,-1);
                while (!sorted) {
                    if (stopExecution) {
                        break;
                    }
                    gap = Math.floor(gap / shrink);
                    if (gap <= 1) {
                        gap = 1;
                    }
                    let swapped = false;
                    for (let i = 0; i + gap < n; i++) {
                        comparaisonCount++;
                        if (array[i] > array[i + gap]) {
                            echangeCount++;
                            indexfuctionswap(i, i + gap);
                            // Échange les éléments
                            let temp = array[i];
                            array[i] = array[i + gap];
                            array[i + gap] = temp;
                            swapped = true;
                            // Dessine le tableau après chaque échange
                            drawArray(array);
                            await new Promise(resolve => setTimeout(resolve, awaittime));
                            if(reset) {
                                resetFunction();
                                reset=false;
                                running=false;
                                return;
                            }
                            if(stopExecution) {
                                while(!(onestep||resume)){
                                    await new Promise(resolve => setTimeout(resolve, 50));
                                }
                                if(onestep) {
                                    onestep=false;
                                    stopExecution=true;
                                }
                                if(resume) {
                                    resume=false;
                                    stopExecution=false;
                                    onestep=false;
                                }
                                if (reset) {
                                    resetFunction();
                                    reset = false;
                                    running = false;
                                    return;
                                }
                            }
                        }
                    }
                    if(!swapped){sorted = true;}
                }
                endTime = performance.now();
                const executionTime = endTime - startTime;
                console.log("Temps d'exécution pour le tri à peigne (s) : ", executionTime/1000);
                const executionTimeElement = document.getElementById('executionTime');
                executionTimeElement.innerText = `Temps d'exécution : ${(executionTime/1000).toFixed(2)} s`;
                executionTimeElement.innerText += `\nNombre de comparaisons : ${comparaisonCount}`;
                executionTimeElement.innerText += `\nNombre d'échanges : ${echangeCount}`;
                running=false;
            }

            // Fonction pour effectuer le tri par tas et dessiner chaque étape sur le canvas
            async function heapSort() {
                startTime = performance.now();
                startFunction();
                running=true;
                comparaisonCount = 0;
                echangeCount = 0;
                indexfuctionswap(-1,-1);
                function heapify(arr, n, i) {
                    let largest = i;
                    let l = 2 * i + 1;
                    let r = 2 * i + 2;
                    if (l < n) {
                        comparaisonCount++;
                        if (arr[l] > arr[largest]) {
                            largest = l;
                        }
                    }
                    if (r < n && arr[r] > arr[largest]) {
                        largest = r;
                    }

                    if (largest !== i) {
                        echangeCount++;
                        indexfuctionswap(i,largest);
                        let temp = arr[i];
                        arr[i] = arr[largest];
                        arr[largest] = temp;
                        heapify(arr, n, largest);
                    }
                }

                for (let i = Math.floor(n / 2) - 1; i >= 0; i--) {
                    heapify(array, n, i);
                }

                for (let i = n - 1; i > 0; i--) {
                    if (stopExecution) {
                        break;
                    }
                    let temp = array[0];
                    array[0] = array[i];
                    array[i] = temp;
                    heapify(array, i, 0);
                    drawArray(array);
                    await new Promise(resolve => setTimeout(resolve, awaittime));

                    if(reset) {
                        resetFunction();
                        reset=false;
                        running=false;
                        return;
                    }
                    if(stopExecution) {
                        while(!(onestep||resume)){
                            await new Promise(resolve => setTimeout(resolve, 50));
                        }
                        if(onestep) {
                            onestep=false;
                            stopExecution=true;
                        }
                        if(resume) {
                            resume=false;
                            stopExecution=false;
                            onestep=false;
                        }
                        if (reset) {
                            resetFunction();
                            reset = false;
                            running = false;
                            return;
                        }
                    }
                }
                endTime = performance.now();
                const executionTime = endTime - startTime;
                console.log("Temps d'exécution pour le tri par tas s) : ", executionTime/1000);
                const executionTimeElement = document.getElementById('executionTime');
                executionTimeElement.innerText = `Temps d'exécution : ${(executionTime/1000).toFixed(2)} s`;
                executionTimeElement.innerText += `\nNombre de comparaisons : ${comparaisonCount}`;
                executionTimeElement.innerText += `\nNombre d'échanges : ${echangeCount}`;
                running=false;
            }

            // Fonction pour effectuer le tri rapide et dessiner chaque étape sur le canvas
            async function quickSort() {
                startTime = performance.now();
                startFunction();
                running=true;
                comparaisonCount = 0;
                echangeCount = 0;
                indexfuctionswap(-1,-1);
                async function partition(low, high) {
                    let pivot = array[high];
                    let i = low - 1;
                    for (let j = low; j < high; j++) {
                        comparaisonCount++;
                        if (array[j] < pivot) {
                            i++;
                            echangeCount++;
                            indexfuctionswap(i,j);
                            let temp = array[i];
                            array[i] = array[j];
                            array[j] = temp;
                        }
                    }
                    echangeCount++;
                    let temp = array[i + 1];
                    array[i + 1] = array[high];
                    array[high] = temp;
                    drawArray(array);
                    await new Promise(resolve => setTimeout(resolve, awaittime));
                    if(reset) {
                        return;
                    }
                    if(stopExecution) {
                        while(!(onestep||resume)){
                            await new Promise(resolve => setTimeout(resolve, 50));
                        }
                        if(onestep) {
                            onestep=false;
                            stopExecution=true;
                        }
                        if(resume) {
                            resume=false;
                            stopExecution=false;
                            onestep=false;
                        }
                        if (reset) {
                            reset = false;
                            resetFunction();
                            running = false;
                            return;
                        }
                    }
                    return i + 1;
                }

                async function quickSortHelper(low, high) {
                    if (low < high) {
                        let pi = await partition(low, high);
                        await quickSortHelper(low, pi - 1);
                        await quickSortHelper(pi + 1, high);
                    }
                }
                await quickSortHelper(0, n - 1);
                endTime = performance.now();
                const executionTime = endTime - startTime;
                console.log("Temps d'exécution pour le tri rapide(s) : ", executionTime/1000);
                const executionTimeElement = document.getElementById('executionTime');
                executionTimeElement.innerText = `Temps d'exécution : ${(executionTime/1000).toFixed(2)} s`;
                executionTimeElement.innerText += `\nNombre de comparaisons : ${comparaisonCount}`;
                executionTimeElement.innerText += `\nNombre d'échanges : ${echangeCount}`;
                running=false;
            }

            // Fonction pour effectuer le tri fusion et dessiner chaque étape sur le canvas
            async function mergeSort() {
                let startTime, endTime;
                startTime = performance.now();
                startFunction();
                comparaisonCount = 0;
                echangeCount = 0;
                running = true;
                await mergeSortHelper(array, 0, n - 1); // Attendre la fin de mergeSortHelper
                endTime = performance.now();
                const executionTime = endTime - startTime;

                console.log("Temps d'exécution pour le tri fusion (s) : ", executionTime/1000);
                const executionTimeElement = document.getElementById('executionTime');
                executionTimeElement.innerText = `Temps d'exécution : ${(executionTime/1000).toFixed(2)}s`;
                executionTimeElement.innerText += `\nNombre de comparaisons : ${comparaisonCount}`;
                executionTimeElement.innerText += `\nNombre d'échanges : ${echangeCount}`;
                running = false;
            }

            async function mergeSortHelper(arr, left, right) {
                if (left < right) {
                    let middle = Math.floor((left + right) / 2);
                    await mergeSortHelper(arr, left, middle);
                    await mergeSortHelper(arr, middle + 1, right);
                    await merge(arr, left, middle, right);
                }
            }

            async function merge(arr, left, middle, right) {
                let leftArr = arr.slice(left, middle + 1);
                let rightArr = arr.slice(middle + 1, right + 1);
                let leftIndex = 0;
                let rightIndex = 0;
                let index = left;
                indexfuctionswap(-1,-1);
                while (leftIndex < leftArr.length && rightIndex < rightArr.length) {
                    comparaisonCount++; // Incrémenter le compteur de comparaisons
                    if (leftArr[leftIndex] <= rightArr[rightIndex]) {
                        arr[index] = leftArr[leftIndex];
                        leftIndex++;
                    }else {
                        arr[index] = rightArr[rightIndex];
                        rightIndex++;
                    }
                    index++;
                    echangeCount++; // Incrémenter le compteur d'échanges
                }
                while (leftIndex < leftArr.length) {
                    arr[index] = leftArr[leftIndex];
                    leftIndex++;
                    index++;
                    echangeCount++; // Incrémenter le compteur d'échanges
                }

                while (rightIndex < rightArr.length) {
                    arr[index] = rightArr[rightIndex];
                    rightIndex++;
                    index++;
                    echangeCount++; // Incrémenter le compteur d'échanges
                }

                drawArray(arr);
                await new Promise(resolve => setTimeout(resolve, awaittime));
                if (reset) {
                    reset = false;
                    running = false;
                    return;
                }
                if (stopExecution) {
                    while (!(onestep || resume || reset)) {
                        await new Promise(resolve => setTimeout(resolve, 50));
                    }
                    if (onestep) {
                        onestep = false;
                        stopExecution = true;
                    }
                    if (resume) {
                        resume = false;
                        stopExecution = false;
                        onestep = false;
                    }
                    if (reset) {
                        reset = false;
                        endTime = performance.now();
                        running = false;
                        return;
                    }
                }
            }

            // Appelle la fonction de tri appropriée en fonction de la valeur sélectionnée
            running = false; // Réinitialiser la valeur de running à false
            if (selectValue == 1) {
                bubbleSort();
            } else if (selectValue == 2) {
                selectionSort();
            } else if (selectValue == 3) {
                combSort();
            } else if (selectValue == 4) {
                heapSort();
            } else if (selectValue == 5) {
                quickSort();
            } else if (selectValue == 6) {
                mergeSort();
            }
        }

        // Fonction pour générer un tableau de nombres aléatoires
        function generateRandomArray(taille) {
            // Crée un tableau vide de la taille spécifiée
            var tableau = new Array(taille);

            // Remplit le tableau avec des valeurs consécutives
            for (var i = 0; i < taille; i++) {
                tableau[i] = i + 1;
            }

            // Mélange les éléments du tableau de manière aléatoire
            for (var i = taille - 1; i > 0; i--) {
                var j = Math.floor(Math.random() * (i + 1));
                var temp = tableau[i];
                tableau[i] = tableau[j];
                tableau[j] = temp;
            }

            // Retourne le tableau rempli
            return tableau;
        }

        const selectElement = document.querySelector('#mySelect');
        selectElement.addEventListener('change', () => {
            if (running) {
                stopExecution = true;
            }
            getSelectValue();
            getValueInput();
            var array = generateRandomArray(ValueInput);
            running = false; // Réinitialiser la valeur de running à false
            drawArray(array);
        });
    </script>
</body>
</html>
