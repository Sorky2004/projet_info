<!DOCTYPE html>
<html lang="fr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Visualisation des algorithmes de tri</title>
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <style>
        #chart-container {
            margin-top: 20px;
            width: 600px;
            height: 400px;
        }
        #performance-indicators {
            margin-top: 20px;
        }
    </style>
</head>
<body>
    <h1>Visualisation des algorithmes de tri</h1>
    <label for="algorithm-select">Choisissez un algorithme de tri :</label>
    <select id="algorithm-select">
        <option value="selection">Tri par sélection</option>
        <option value="bubble">Tri à bulle</option>
        <option value="comb">Tri à peigne</option>
        <option value="heap">Tri par tas</option>
        <option value="quick">Tri rapide</option>
    </select>
    <button onclick="runAlgorithm()">Exécuter</button>
    <div id="chart-container"></div>
    <div id="performance-indicators"></div>

    <script>
        function plotGraph(data, title) {
            const chartContainer = document.getElementById('chart-container');
            chartContainer.innerHTML = '';
            const canvas = document.createElement('canvas');
            chartContainer.appendChild(canvas);
            const ctx = canvas.getContext('2d');

            new Chart(ctx, {
                type: 'bar',
                data: {
                    labels: Array.from({ length: data.length }, (_, i) => i + 1),
                    datasets: [{
                        label: title,
                        data: data,
                        backgroundColor: 'rgba(54, 162, 235, 0.2)',
                        borderColor: 'rgba(54, 162, 235, 1)',
                        borderWidth: 1
                    }]
                },
                options: {
                    scales: {
                        yAxes: [{
                            ticks: {
                                beginAtZero: true
                            }
                        }]
                    }
                }
            });
        }

        async function sleep(ms) {
            return new Promise(resolve => setTimeout(resolve, ms));
        }

        async function runAlgorithm() {
            const algorithmSelect = document.getElementById('algorithm-select');
            const selectedAlgorithm = algorithmSelect.value;

            let algorithmFunction;
            switch (selectedAlgorithm) {
                case 'selection':
                    algorithmFunction = selectionSort;
                    break;
                case 'bubble':
                    algorithmFunction = bubbleSort;
                    break;
                case 'comb':
                    algorithmFunction = combSort;
                    break;
                case 'heap':
                    algorithmFunction = heapSort;
                    break;
                case 'quick':
                    algorithmFunction = quickSort;
                    break;
                default:
                    return;
            }

            const data = generateRandomData(100); // Générer des données aléatoires
            let comparisons = 0;
            let swaps = 0;
            const startTime = performance.now();

            for (let i = 0; i < data.length - 1; i++) {
                const result = await algorithmFunction(data, i);
                comparisons += result.comparisons;
                swaps += result.swaps;
                plotGraph(data.slice(), `${selectedAlgorithm} (Étape ${i + 1} sur ${data.length - 1})`);
                await sleep(100); // Attendre 100 millisecondes entre chaque étape pour visualiser le défilement
            }

            const endTime = performance.now();
            const executionTime = (endTime - startTime) / 1000; // Convertir en secondes

            const performanceIndicators = document.getElementById('performance-indicators');
            performanceIndicators.innerHTML = `Temps d'exécution : ${executionTime.toFixed(3)} secondes, Comparaisons : ${comparisons}, Échanges : ${swaps}`;
        }

        function generateRandomData(size) {
            const data = [];
            for (let i = 0; i < size; i++) {
                data.push(Math.floor(Math.random() * 100));
            }
            return data;
        }

        // Implémentez vos fonctions de tri ici
        async function selectionSort(arr, i) {
            // Implémentation du tri par sélection
            let minIdx = i;
            let comparisons = 0;
            let swaps = 0;
            for (let j = i + 1; j < arr.length; j++) {
                comparisons++;
                if (arr[j] < arr[minIdx]) {
                    minIdx = j;
                }
            }
            if (minIdx !== i) {
                swaps++;
                [arr[i], arr[minIdx]] = [arr[minIdx], arr[i]];
            }
            return { comparisons, swaps };
        }

        async function bubbleSort(arr, i) {
            // Implémentation du tri à bulle
            let comparisons = 0;
            let swaps = 0;
            for (let j = 0; j < arr.length - i - 1; j++) {
                comparisons++;
                if (arr[j] > arr[j + 1]) {
                    swaps++;
                    [arr[j], arr[j + 1]] = [arr[j + 1], arr[j]];
                }
            }
            return { comparisons, swaps };
        }

        async function combSort(arr, i) {
            // Implémentation du tri à peigne
            // Cette fonction n'a pas besoin de l'indice i car elle parcourt toute la liste à chaque étape
            let gap = arr.length;
            let shrink = 1.3;
            let sorted = false;
            let comparisons = 0;
            let swaps = 0;
            while (!sorted) {
                gap = Math.floor(gap / shrink);
                if (gap <= 1) {
                    gap = 1;
                    sorted = true;
                }
                let swapped = false;
                for (let j = 0; j + gap < arr.length; j++) {
                    comparisons++;
                    if (arr[j] > arr[j + gap]) {
                        swaps++;
                        [arr[j], arr[j + gap]] = [arr[j + gap], arr[j]];
                        swapped = true;
                    }
                }
                if (!swapped) {
                    sorted = true;
                }
            }
            return { comparisons, swaps };
        }

        async function heapSort(arr, i) {
            // Implémentation du tri par tas
            // Cette fonction n'a pas besoin de l'indice i car elle parcourt toute la liste à chaque étape
            function heapify(arr, n, i) {
                let largest = i;
                let l = 2 * i + 1;
                let r = 2 * i + 2;

                if (l < n && arr[l] > arr[largest]) {
                    largest = l;
                }

                if (r < n && arr[r] > arr[largest]) {
                    largest = r;
                }

                if (largest !== i) {
                    [arr[i], arr[largest]] = [arr[largest], arr[i]];
                    heapify(arr, n, largest);
                }
            }

            const n = arr.length;
            let comparisons = 0;
            let swaps = 0;

            for (let i = Math.floor(n / 2) - 1; i >= 0; i--) {
                heapify(arr, n, i);
            }

            for (let i = n - 1; i > 0; i--) {
                [arr[0], arr[i]] = [arr[i], arr[0]];
                swaps++;
                heapify(arr, i, 0);
            }
            return { comparisons, swaps };
        }

        async function quickSort(arr, i) {
            // Implémentation du tri rapide
            // Cette fonction n'a pas besoin de l'indice i car elle parcourt toute la liste à chaque étape
            if (arr.length <= 1) {
                return { comparisons: 0, swaps: 0 };
            }
            const pivot = arr[Math.floor(arr.length / 2)];
            let comparisons = 0;
            let swaps = 0;
            const left = [];
            const right = [];
            for (const num of arr) {
                comparisons++;
                if (num < pivot) {
                    left.push(num);
                } else if (num > pivot) {
                    right.push(num);
                }
            }
            const leftResult = await quickSort(left);
            const rightResult = await quickSort(right);
            return { comparisons: comparisons + leftResult.comparisons + rightResult.comparisons, swaps: swaps + leftResult.swaps + rightResult.swaps };
        }
    </script>
</body>
</html>
