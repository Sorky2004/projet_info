<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Mon Application Web</title>
    <style>
        /* Styles CSS pour le bouton */
        .button {
            background-color: #4CAF50; /* couleur de fond verte */
            border: none;
            color: white; /* couleur du texte blanc */
            padding: 15px 32px; /* taille du bouton */
            text-align: center;
            text-decoration: none;
            display: inline-block;
            font-size: 16px;
            margin: 4px 2px;
            cursor: pointer;
            border-radius: 10px; /* coins arrondis */
            box-shadow: 0 4px 8px 0 rgba(0,0,0,0.2); /* ombre */
            transition: box-shadow 0.3s ease; /* transition douce de l'ombre */
        }
        /* Au survol, agrandir légèrement le bouton */
        .button:hover {
            box-shadow: 0 8px 16px 0 rgba(0,0,0,0.2);
        }
        /* Styles CSS pour le canvas */
        canvas {
            border: 1px solid black;
        }
    </style>
</head>
<body>
    <h1>Bienvenue sur Mon Application Web !</h1>
    <p>Cette application est en cours de développement. voici ce qu'il faut rajouter :</p>
    <ul>
        <li>performance du tri :temps d'execution (avec ou sans l'attente jsp), nombre de comparaison, nombre de déplacement de vlaeur</li>
        <li>boutton d'arret complet + si on stop puis recommence ça reste statique</li>
        <li>pouvoir selecioner entre quoi et quoi les valeurs sont comprisent </li>
        <li> rajouter de algorithmes</li>
        <li>rendre ça beau </li>
    </ul>

    <select id="mySelect">
        <option value="1">Tri à bulles</option>
        <option value="2">Tri par sélection</option>
        <option value="3">Tri à peigne</option>
        <option value="4">Tri par tas</option>
        <option value="5">Tri rapide</option>
        <option value="6">Tri fusion</option> <!-- Ajout d'une option pour le tri fusion -->
        <!-- Ajoute d'autres options pour d'autres algorithmes de tri -->
    </select>
    <canvas id="visualization" width="800" height="400"></canvas>

    <button id="idbutton" class="button" onclick="SortVisualization()">Démarrer le tri</button>

    <label for="arraySize">Taille du tableau : </label>
    <input type="number" id="arraySize" name="arraySize" min="1" max="1000" value="100">

    <div id="errorMessage" style="display: none; color: red;"></div>

    <button class="button" onclick="stopFunction()">pause</button>
    <button class="button" onclick="resumeFunction()">resume</button>
    <button class="button" onclick="onestepFunciton()">one step</button>
    <button class="button" onclick="reinitialiserFunction()">reinitialiser</button>

    <script>
        //constantes :
        let selectValue;
        let valueinput;
        let stopExecution = false;
        let onestep = false;
        let resume = false;
        let running = false;
        let reinitialiser = false;

        //récupère la valeur dans le choix du tri
        function getSelectValue() {
            const selectElement = document.querySelector('#mySelect');
            selectValue = selectElement.value;
        }

        function getValueinput() {
            var inputElement = document.getElementById("arraySize");
            // Récupérer la valeur de l'attribut value
            valueinput = inputElement.value;
        }

        function stopFunction() {
        stopExecution = true;
        }

        function onestepFunciton() {
            onestep = true;
        }

        function resumeFunction() {
            resume=true;
        }

        function reinitialiserFunction(){
            reinitialiser=true;
        }

        function startfunction(){
        stopExecution = false;
        onestep = false;
        resume = false;
        }

        //affiche le message d'erreur
        function afficherErreur(message) {
            var errorMessageElement = document.getElementById("errorMessage");
            errorMessageElement.innerText = message;
            errorMessageElement.style.display = "block";
        }

        // Fonction de fusion pour le tri fusion
 function merge(left, right) {
            let result = [];
            let indexLeft = 0;
            let indexRight = 0;

            while (indexLeft < left.length && indexRight < right.length) {
                if (left[indexLeft] < right[indexRight]) {
                    result.push(left[indexLeft]);
                    indexLeft++;
                } else {
                    result.push(right[indexRight]);
                    indexRight++;
                }
            }

            return result.concat(left.slice(indexLeft)).concat(right.slice(indexRight));
        }

        // Fonction de tri fusion récursive
        function mergeSort(array) {
            if (array.length <= 1) {
                return array;
            }

            const middle = Math.floor(array.length / 2);
            const left = array.slice(0, middle);
            const right = array.slice(middle);

            return merge(mergeSort(left), mergeSort(right));
        }

        // Fonction pour générer un tableau de nombres aléatoires
        function generateRandomArray(taille) {
            // Crée un tableau vide de la taille spécifiée
            var tableau = new Array(taille);

            // Remplit le tableau avec des valeurs consécutives
            for (var i = 0; i < taille; i++) {
                tableau[i] = i + 1;
            }

            // Mélange les éléments du tableau de manière aléatoire
            for (var i = taille - 1; i > 0; i--) {
                var j = Math.floor(Math.random() * (i + 1));
                var temp = tableau[i];
                tableau[i] = tableau[j];
                tableau[j] = temp;
            }

            // Retourne le tableau rempli
            return tableau;
        }

        async function SortVisualization() {

            if(running){return;}
            getSelectValue();
            getValueinput();
            if(valueinput <3 || valueinput > 1000) {
                afficherErreur("la valeur doit être comrpis entre 3 et 1000");
                return;
            }
            stopExecution = false;
            onestep = false;
            resume = false;
            running = false;
            reinitialiser = false;

            var canvas = document.getElementById("visualization");
            var ctx = canvas.getContext("2d");
            var array = generateRandomArray(valueinput); // Génère un tableau de valueinput éléments aléatoires

            // Fonction pour dessiner le tableau sur le canvas
            function drawArray() {
                ctx.clearRect(0, 0, canvas.width, canvas.height);
                var barWidth = canvas.width / array.length;
                for (var i = 0; i < array.length; i++) {
                    var barHeight = array[i] * (canvas.height / array.length);
                    ctx.fillStyle = "blue";
                    ctx.fillRect(i * barWidth, canvas.height - barHeight, barWidth, barHeight);
                }
            }

            drawArray();
            running = true;

            if (selectValue == 1) {
                await bubbleSort(array, drawArray, stopExecution, onestep, resume);
            } else if (selectValue == 2) {
                await selectionSort(array, drawArray, stopExecution, onestep, resume);
            } else if (selectValue == 3) {
                await combSort(array, drawArray, stopExecution, onestep, resume);
            } else if (selectValue == 4) {
                await heapSort(array, drawArray, stopExecution, onestep, resume);
            } else if (selectValue == 5) {
                await quickSort(array, 0, array.length - 1, drawArray, stopExecution, onestep, resume);
            } else if (selectValue == 6) { // Appel de la fonction de tri fusion
                await mergeSortVisualization(array, drawArray, stopExecution, onestep, resume);
            }

            running = false;
        }

        // Fonction pour la visualisation du tri fusion
        async function mergeSortVisualization(array, drawArray, stopExecution, onestep, resume) {
            if (array.length <= 1) {
                return array;
            }

            const middle = Math.floor(array.length / 2);
            const left = array.slice(0, middle);
            const right = array.slice(middle);

            await mergeSortVisualization(left, drawArray, stopExecution, onestep, resume);
            await mergeSortVisualization(right, drawArray, stopExecution,
 resume);

            let mergedArray = merge(left, right);
            for (let i = 0; i < mergedArray.length; i++) {
                if (stopExecution) {
                    while(!(onestep||resume)){
                        await new Promise(resolve => setTimeout(resolve, 50));
                    }
                    if(onestep) {
                        onestep=false;
                        stopExecution=true;
                    }
                    if(resume) {
                        resume=false;
                        stopExecution=false;
                        onestep=false;
                    }
                }
                array[i] = mergedArray[i];
                drawArray();
                await new Promise(resolve => setTimeout(resolve, 10));
            }

            return array;
        }
    </script>
</body>
</html>
